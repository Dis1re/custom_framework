// Функциональные компоненты в реакт

// функциональная компонента обязательно должна возвращать разметку
// Главное отличие от классовой, что когда классовая компонента при смене сосотояния меняется полностью,
// Но отсутствуют методы классовой компоненты реакта и отнаследовать 
// использование функциональных компонент в разметке других компонент: если в классовой 
// компоненты мы кидали пропсы в конструктор, то в функциональной мы кидаем их в аргументы
// Зачем функциональные если есть классовые? А затем, потому что вызывать каждый раз экземпляр класса затратно 
// для Функциональных компонент применимо жесткое правило инкапсуляции, то есть вне фукнциональной компоненты 
// не должно быть никаких сложных типов данных, только простые контстанты
// Понятие хуков: хуки - это стандартные или самописные функции, которые расширяют функционал функциональной функции
// можно писать свои хуки, и это приветсвуется. 
// Если хук локальный и используется в одной компоненте, то его можно написать рядом с используемой компонентой,
// а если хук используется в нескольких компонентах, то в src создается папка hooks и он записывается туда.
// все хуки начинаются со слова use.

// Первый полезный хук: 

// useState - это функция которая возращает массив из двух элементов: 
// 1 - константа - значение текущего состояния, 
// 2 - функция с помощью которой состояние изменяется, 
// в аргумент useState можно передать начальное состояние функции.
import {useState} from "react";
const App = () => {
    const [pageName, setPageName] = useState('Graph3D');

    return (<>
    <Header setPageName={setPageName}/>
    {pageName === 'Graph3D' && <Graph3D />}
     {/* также расписать другие компоненты */}
    </>);
}

// второй очень полезный хук:
// useRef - хук возвращает ссылочный объект, который вписывается в аттрибут ref Html элемента.

import {useRef} from 'react';
const Calc = () => {
    const aRef = useRef();
    const bRef = useRef();
    // aRef.curren.value - возвращаемое значение
    //...
    return (<>
        <textarea  ref={aRef}></textarea>
        <textarea  ref={bRef}></textarea>
    </>);
}
// note: handler'ы элементов в разметке, которые используются элементами, объявляются внутри этой компоненты

// для того чтобы каждый раз не создавать обработчик событий, можно запомнить созданный handler с помощью хука useCallback

// третий не очень полезный хук: 
// useCallback - в него передаются фугкция которыую надо запомнить, и он возвращает ссылку на эту же функцию;

const clickHandler = useCallback(()=> { /*какой-то handler*/ }, []); // второй аргумент - это зависимости, но туда нужно обязательно что-то вписать.
// этот хук - довольно бесплолезный, потому что таких моментов не должно происхожить

// четвертый может быть полезный хук:
// useMemo - запоминает состояние и возвращает ссылку.

// пятый очень полезный хук:
// useEffect - хук, который вызывает перерисовку компоненты, в случае изменения зависимостей, которые в него переданы.
// если в него не переданы никакие зависимости, он будет вызван один раз, после завершения рендера разметки компопнеты.
// то есть можно его использовать как аналог componentDidMount

// 1 - аргумент, это функция, которая сработает, когда useEffect сработает.
// 2 - аргумент, это массив зависимостей.
useEffect(() => { 
    /*какой-то код*/ 
    return() => {
        /*какой-то код, который выполнится после уничтожения компоненты*/
    }
});

// useEffect'ов в компоненты может быть несколько и с разными зависимостями.
// если useEffect испоользуется без зависимостей, то функция, передаваемая в useEffect может возвращать ещё одну функцию,
// которая будет вызвана при уничтожении компоненты.

// запрещено хуки использовать друг в друге

// note: useEffect нужен будет в graph3D и graph2D, чтобы использовать его как componentDidMount
const Graph2D = () => {
    let graph = null;
    //...
    useEffect(()=>{
        graph = new Graph({/* ... */}); //- сallback'и - можно объявить вне useEffect
        return () => {
            graph = null;
            //...
        }
    });
}
// note: нужно обязательн сделать проверку на существование графа в рендере сцены.

// китайская мудрость: - если вы пишете код, и его нельзя за вечер переписать на другой фреймворк, то вы страдаете хернёй. @А.С.Трусов

// 99% процентов задач закрывает useEffect и useRef.

// пример фигуры на классе:
class Cube extends Surface{
    constructor() {
        super({});
        const points = [];
        const edges = [];
        const polygons = [];
        //заполняем точки, ребра, полигоны
        this.points = points;
        this.edges = edges;
        this.polygons = polygons;
    }
}

// css поддерживает несколько систем исчисления:
// - пиксели
// - проценты
// - rem
// note: в одном проекте должен использоваться строго одна система исчисления


// дезешечка: 
// - необходиме переписать на функциональные компоненты App, Header, Graph3D, Graph2D и другие.
// - в math3D переписать все поверхности фигуры на классы наследуемые от класс Surface.
// - в проекте не должно остаться прототипов вообще
// - * написать хук useGraph, который возвращает массив из трёх элементов: // он должен быть записан в modelus рядом с Graph2D 
//                                             1 - Ссылка на граф
//                                             2 - callback для функции renderScene, для вызова в requestAnimationFrame
//                                             3 - функция деинициализатор, которая останавливает requestAnimationFrame и удаляет граф
// - ** все стили с *.css переписать на *.scss